<html>
<title> Inductive Data Structures </title>
<body bgcolor=#08FFFF>
<h1> Inductive Data Structures </h1>
<a href="SRC/chap6.v"> Sources of examples from the book </a> 
<h2> Exercises </h2>
<h3> Types without recursion </h3>
 <a href="seasons.html"> Exercise 6.1 page 139 </a> On seasons 
<br>
<a href="bool_cases.html"> Exercise 6.3 page 140 </a> Using <tt>bool_ind</tt>
<br> <a href="more-seasons.html"> Exercise 6.4 page 144 </a> On seasons (continued)
<br> <a href="exobool.html"> Exercise 6.6 page 144 </a> Computing on booleans
<br> <a href="manhattan.html"> Exercise 6.8 page 146 </a> Manhattan distance
<br> <a href="nbseats.html"> Exercise 6.9 page 148 </a> Functions defined by cases without <tt>match</tt>

<h3> Case based reasoning </h3>

<br> <a href="is_January.html"> Exercise 6.10 page 153 </a> Applying <tt>mont_rect</tt>
<br> <a href="bool-discr.html"> Exercise 6.11 page 153 </a> A manual proof of discrimination 
<br> <a href="Rat.html"> Exercise 6.13 page 156 </a> About the danger of axioms

<br> <font color=red>New! </font> <a href="partialfunc.html"> On partial functions </a>
<h3> Recursive types </h3>

 <a href="lt_3.html"> Exercise 6.15 page 166 </a> Definition by cases
<br> <a href="rplus.html"> Exercise 6.16 page 166 </a> Another definition of addition  
<br> <a href="exo-sum-f.html"> Exercise 6.17 page 166 </a> Computing <em>f(0)+f(1)+...f(n)</em> 
<br> <a href="two_power.html"> Exercise 6.18 page 166 </a> Computing 2<sup>n</sup>

<br> <a href="positive.html"> Exercise 6.19 page 169 </a> Representation of positive numbers
<br> <a href="pos_even_bool.html"> Exercise 6.20 page 169 </a> On even positive numbers 
<br> <a href="pos_div4.html"> Exercise 6.21 page 169 </a> Division by 4  
<br> <a href="propositional.html"> Exercise 6.23 page 169 </a> Propositional formulae 
<br> <a href="exo_frac.html"> Exercise 6.24 page 169 </a> On fractions  
<br> <a href="value_present.html"> Exercise 6.25 page 169 </a> Looking for a value in a tree  

<br> <a href="power_log.html">  Exercise 6.26 page 170  </a> Logarithm and power 
<br> <a href="fzero_present.html">  Exercise 6.27 page 171 </a> Representing trees with functions 
<br> <a href="izero-present.html"> Exercise 6.28 page 172 </a> Finding 0 in an infinitely branching tree
<br> <a href="plus_n_O.html"> Exercise 6.29 page 173 </a> A simple proof by elimination  
<br> <a href="tree_bij.html">  Exercise 6.30 page 173 </a> Representing trees with functions (continued)
<br> <a href="mult2.html"> Exercise 6.31 page 174</a> A simple proof by induction 
<br> <a href="sum.html">  Exercises 6.32 and 6.33  page 174 </a> On the sum of the <em>n</em> first natural numbers 


<h3> Polymorphic types </h3>
<a href="twofirst.html"> Exercise 6.34 and 6.35 page 177 </a> A simple polymorphic function on lists  
<br> <a href="iota.html"> Exercise 6.38 page 177 </a> On the list <tt>1::2:: ... <em>n</em>::nil</tt>.

<br> <a href="nth_length.html"> Exercise 6.40 page 178 </a> On (too) short lists 
<br> <a href="first-in-list.html"> Exercise 6.41 page 179 </a> Finding the first element satisfying a boolean predicate in a list
<br> <a href="split.html"> Exercise 6.42 page 179 </a> Splitting and combining lists
<br> <a href="poly_tree.html"> Exercise 6.43 page 179 </a> Monomorphic binary trees and polymorphic trees
<br> <a href="erato.html"> Exercise 6.45 page 179 </a> Computing prime numbers  

<h3> Dependent inductive types </h3>

 <a href="man_inj.html"> Exercise 6.46 page 183 </a> Manual injection on variably dependent types
<br> <a href="height.html"> Exercise 6.47 page 183 </a> Trees with fixed height
<br> <a href="binary_word.html"> Exercise 6.48 page 183 </a> Binary words
<br> <a href="binary_word_or.html"> Exercise 6.49 page 183</a>Bit-wise or on binary words 
 <br> <a href="vectors.html">  Polymorphic vectors  </a>
<br> <a href="depfun.html">  Exercise 6.50 page 183 </a> A function returning a value in a dependent type 
<h3> Empty types </h3> 

<br> <a href="emptyset.html">Exercise 6.51 page 183</a> On the empty set 



<br>
<h2> Errata </h2>
<ol>
<li> Exercise 6.32 page 174 <br>
The correct statement is <a href="sum.html">here</a>
<li> Section 6.1.3, paragraph 4 p 141,<br> read "; apply T_ind2" instead of "; apply T_ind"
</ol>
<br>
<hr>

</body>
</html>
